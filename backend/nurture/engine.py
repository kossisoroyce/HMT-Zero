"""
Main Nurture Layer engine - orchestrates the full interaction loop.
"""
import re
from datetime import datetime
from typing import Dict, Any, Tuple, Optional, Callable, List

from .config import NurtureConfig, DEFAULT_CONFIG
from .state import NurtureState, EvaluationResult, InteractionMetadata, initialize_nurture_state
from .significance import compute_significance, should_evaluate, get_dynamic_threshold
from .evaluation import create_evaluation_prompt, parse_evaluation, extract_basic_features
from .updates import (
    update_N_env, update_env_json, update_N_stance,
    update_stability, compute_plasticity, check_for_shock,
    process_shock, update_stable_count
)
from .context import (
    assemble_context, create_response_prompt_with_significance,
    DEFAULT_SYSTEM_PROMPT
)


class NurtureEngine:
    """
    Main engine for processing interactions through the Nurture Layer.
    """
    
    def __init__(
        self,
        config: NurtureConfig = DEFAULT_CONFIG,
        model_fn: Optional[Callable[[str], str]] = None,
        system_prompt: str = DEFAULT_SYSTEM_PROMPT
    ):
        """
        Initialize the Nurture Engine.
        
        Args:
            config: Configuration parameters
            model_fn: Function to call the LLM (input: prompt, output: response)
            system_prompt: Base system prompt
        """
        self.config = config
        self.model_fn = model_fn
        self.system_prompt = system_prompt
    
    def set_model_fn(self, model_fn: Callable[[str], str]):
        """Set the model function for LLM calls."""
        self.model_fn = model_fn
    
    def create_instance(self, instance_id: Optional[str] = None) -> NurtureState:
        """Create a new nurture state instance."""
        return initialize_nurture_state(
            instance_id=instance_id,
            d_env=self.config.D_ENV,
            d_stance=self.config.D_STANCE
        )
    
    def process_interaction(
        self,
        user_input: str,
        nurture_state: NurtureState,
        conversation_history: List[Dict[str, str]] = None,
        assistant_response: Optional[str] = None
    ) -> Tuple[str, NurtureState, InteractionMetadata]:
        """
        Process a single interaction through the Nurture Layer.
        
        This is the main loop as specified in the technical paper.
        
        Args:
            user_input: The user's input text
            nurture_state: Current nurture state
            conversation_history: Previous conversation messages
            assistant_response: Pre-generated response (if None, will generate)
        
        Returns:
            Tuple of (response, updated_state, metadata)
        """
        if conversation_history is None:
            conversation_history = []
        
        phase_before = nurture_state.phase
        
        # Step 1: Assemble context with current stance
        context = assemble_context(
            system_prompt=self.system_prompt,
            nurture_state=nurture_state,
            conversation_history=conversation_history,
            current_input=user_input,
            include_phase_info=True,
            include_env_summary=True
        )
        
        # Step 2: Generate response if not provided
        if assistant_response is None:
            if self.model_fn is None:
                # Placeholder response for testing without LLM
                assistant_response = "[Response would be generated by LLM]"
                significance_tag = "medium"
            else:
                # Add significance prompt
                full_prompt = context + create_response_prompt_with_significance()
                raw_response = self.model_fn(full_prompt)
                
                # Extract significance tag
                assistant_response, significance_tag = self._extract_significance_tag(raw_response)
        else:
            significance_tag = "medium"
        
        # Step 3: Compute significance
        significance_score, component_scores = compute_significance(
            user_input,
            nurture_state,
            significance_tag,
            self.config
        )
        
        # Step 4: Check if evaluation needed
        threshold = get_dynamic_threshold(nurture_state.plasticity, self.config)
        needs_evaluation = should_evaluate(significance_score, nurture_state.plasticity, self.config)
        
        delta_magnitude = 0.0
        shock_detected = False
        
        if needs_evaluation:
            # Step 5: Run evaluation pass
            evaluation_result = self._run_evaluation(
                user_input, 
                assistant_response, 
                nurture_state
            )
            
            # Step 6: Update N_env (ungated)
            nurture_state.N_env = update_N_env(
                nurture_state.N_env,
                evaluation_result.environment,
                self.config.ENV_LEARNING_RATE
            )
            nurture_state.env_json = update_env_json(
                nurture_state.env_json,
                evaluation_result.environment,
                self.config.ENV_LEARNING_RATE,
                nurture_state.interaction_count
            )
            
            # Step 7: Update N_stance (gated)
            nurture_state.N_stance, nurture_state.stance_json, delta_magnitude = update_N_stance(
                nurture_state.N_stance,
                nurture_state.stance_json,
                evaluation_result.stance_updates,
                evaluation_result.alignment_score,
                nurture_state.plasticity,
                self.config
            )
            
            # Step 8: Update stability
            nurture_state.stability, nurture_state.delta_history = update_stability(
                nurture_state.stability,
                delta_magnitude,
                nurture_state.delta_history,
                self.config
            )
            
            # Step 9: Check for shock
            shock_boost = check_for_shock(delta_magnitude, nurture_state.plasticity, self.config)
            shock_detected = shock_boost > 0
            
            # Step 10: Update plasticity
            nurture_state.plasticity = compute_plasticity(nurture_state.stability, self.config)
            if shock_detected:
                nurture_state.plasticity = process_shock(
                    nurture_state.plasticity,
                    shock_boost,
                    self.config
                )
            
            # Update stable count
            nurture_state.stable_count = update_stable_count(
                nurture_state.stable_count,
                delta_magnitude
            )
            
            nurture_state.significant_count += 1
        
        else:
            # Minor N_env update only
            basic_features = extract_basic_features(user_input)
            nurture_state.N_env = update_N_env(
                nurture_state.N_env,
                basic_features,
                self.config.MINOR_ENV_LR
            )
            nurture_state.env_json = update_env_json(
                nurture_state.env_json,
                basic_features,
                self.config.MINOR_ENV_LR,
                nurture_state.interaction_count
            )
        
        # Update counters and timestamps
        nurture_state.interaction_count += 1
        nurture_state.last_updated = datetime.now()
        nurture_state.update_phase()
        
        # Create metadata
        metadata = InteractionMetadata(
            significance_score=significance_score,
            significance_tag=significance_tag,
            was_evaluated=needs_evaluation,
            delta_magnitude=delta_magnitude,
            shock_detected=shock_detected,
            phase_before=phase_before,
            phase_after=nurture_state.phase
        )
        
        return assistant_response, nurture_state, metadata
    
    def _extract_significance_tag(self, response: str) -> Tuple[str, str]:
        """Extract significance tag from model response."""
        # Look for [SIGNIFICANCE: xxx] pattern
        match = re.search(r'\[SIGNIFICANCE:\s*(low|medium|high)\]', response, re.IGNORECASE)
        
        if match:
            tag = match.group(1).lower()
            # Remove the tag from the response
            clean_response = re.sub(r'\n?\[SIGNIFICANCE:\s*(low|medium|high)\]', '', response, flags=re.IGNORECASE)
            return clean_response.strip(), tag
        
        return response, "medium"
    
    def _run_evaluation(
        self,
        user_input: str,
        assistant_response: str,
        nurture_state: NurtureState
    ) -> EvaluationResult:
        """
        Run the internal evaluation pass.
        """
        if self.model_fn is None:
            # Return default evaluation for testing
            return EvaluationResult(
                environment={
                    'formality_level': 'neutral',
                    'technical_level': 'intermediate',
                    'emotional_tone': 'neutral',
                    'pace_preference': 'moderate',
                    'key_traits': []
                },
                alignment_score=0.9,
                stance_updates={},
                tensions=[],
                raw_evaluation="[No LLM available for evaluation]"
            )
        
        # Create evaluation prompt
        eval_prompt = create_evaluation_prompt(
            user_input,
            assistant_response,
            nurture_state.env_json,
            nurture_state.stance_json
        )
        
        # Get evaluation from model
        raw_evaluation = self.model_fn(eval_prompt)
        
        # Parse the evaluation
        return parse_evaluation(raw_evaluation)
    
    def get_state_summary(self, nurture_state: NurtureState) -> Dict[str, Any]:
        """Get a human-readable summary of the nurture state."""
        return {
            'instance_id': nurture_state.instance_id,
            'phase': nurture_state.phase,
            'stability': round(nurture_state.stability, 3),
            'plasticity': round(nurture_state.plasticity, 3),
            'interaction_count': nurture_state.interaction_count,
            'significant_count': nurture_state.significant_count,
            'stance': {k: round(v, 3) for k, v in nurture_state.stance_json.items()},
            'environment': nurture_state.env_json,
            'current_threshold': round(
                get_dynamic_threshold(nurture_state.plasticity, self.config), 3
            )
        }


# Convenience function for simple usage
def create_engine(
    model_fn: Optional[Callable[[str], str]] = None,
    config: Optional[NurtureConfig] = None,
    system_prompt: Optional[str] = None
) -> NurtureEngine:
    """Create a NurtureEngine with specified parameters."""
    return NurtureEngine(
        config=config or DEFAULT_CONFIG,
        model_fn=model_fn,
        system_prompt=system_prompt or DEFAULT_SYSTEM_PROMPT
    )
